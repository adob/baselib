#pragma once

#include <functional>

#include "lib/io/io.h"
#include "lib/runtime/symtab.h"
#include "lib/sync/chan.h"
#include "lib/sync/mutex.h"
#include "lib/sync/rwmutex.h"
#include "lib/sync/atomic.h"
#include "lib/time/time.h"

int main(int argc, char *argv[]);

namespace lib::testing {
    struct T;
    struct BenchmarkResult;
    struct B;
    BenchmarkResult benchmark(std::function<void(B &)>);

    namespace detail {
        extern String *skip;

        struct Matcher;
        struct BenchState;
        struct Indenter;

        struct ChattyPrinter {
            io::Writer *w = nil;
            sync::Mutex last_name_mu;  // guards lastName
            String last_name;     // last printed test name in chatty mode
            bool json = false;       // -v=json output mode

            ChattyPrinter(io::Writer *w);

            String prefix() { return ""; }
            
            // updatef prints a message about the status of the named test to w.
            //
            // The formatted message must include the test name itself.
            void update(str test_name, str s);

            // printf prints a message, generated by the named test, that does not
            // necessarily mention that tests's name itself.
            void print(str test_name, str s);
        };

        enum PanicHandling {
            NormalPanic,
            RecoverAndReturnPanic
        } ;


        using testfunc = void (*) (T&);

        struct InternalTest {
            String name;
            testfunc f = nil;
        } ;

        struct InternalBenchmark {} ;
        struct InternalFuzzTarget {} ;
        struct InternalExample {} ;

        std::tuple<bool, bool> run_tests(
            std::function<bool(str pat, str s, error)> match_string,
            view<InternalTest> tests,
            time::time deadline );

        void t_runner(T &t, std::function<void(T&)> const &fn);

        // Common holds the elements common between T and B and
        // captures common methods such as Errorf.
        struct Common {
            // Fail marks the function as having failed but continues execution.
            void fail();

            // failed reports whether the function has failed.
            bool failed() const;

            // fail_now marks the function as having failed and stops its execution
            // by calling runtime.Goexit (which then runs all deferred calls in the
            // current goroutine).
            // Execution will continue at the next test or benchmark.
            // FailNow must be called from the goroutine running the
            // test or benchmark function, not from other goroutines
            // created during the test. Calling FailNow does not stop
            // those other goroutines.
            void fail_now();

            // skip is equivalent to Log followed by SkipNow.
            template <typename... Args>
            void skip(Args const &...args) {
                check_fuzz_fn("skip");
                log(String(fmt::sprintln(args...)));
                skip_now();
            }

            // skip_now marks the test as having been skipped and stops its execution
            // by calling [runtime.Goexit].
            // If a test fails (see Error, Errorf, Fail) and is then skipped,
            // it is still considered to have failed.
            // Execution will continue at the next test or benchmark. See also FailNow.
            // SkipNow must be called from the goroutine running the test, not from
            // other goroutines created during the test. Calling SkipNow does not stop
            // those other goroutines.
            void skip_now();

            bool skipped() const;

            // error is equivalent to Log followed by Fail.
            template <typename... Args>
            void error(Args const &... args) {
                Common &c = *this;
                c.check_fuzz_fn("error");
                c.log_str(String(fmt::sprintln(args...)));
                c.fail();
            }

            // errorf is equivalent to Logf followed by Fail.
            template <typename... Args>
            void errorf(str format, Args const &... args) {
                Common &c = *this;
                c.check_fuzz_fn("errorf");
                c.log_str(String(fmt::sprintf(format, args...)));
                c.fail();
            }

            // Fatal is equivalent to Log followed by FailNow.
            template <typename... Args>
            void fatal(Args const &... args) {
                Common &c = *this;
                c.check_fuzz_fn("fatal");
                c.log_str(String(fmt::sprintln(args...)));
                c.fail_now();
            }

            // Fatalf is equivalent to Logf followed by FailNow.
            template <typename... Args>
            void fatalf(str format, Args const &... args) {
                Common &c = *this;
                c.check_fuzz_fn("fatalf");
                c.log_str(String(fmt::sprintf(format, args...)));
                c.fail_now();
            }

            // Log formats its arguments using default formatting, analogous to Println,
            // and records the text in the error log. For tests, the text will be printed only if
            // the test fails or the -test.v flag is set. For benchmarks, the text is always
            // printed to avoid having performance depend on the value of the -test.v flag.
            // It is an error to call Log after a test or benchmark returns.
            template <typename... Args>
            void log(Args const &... args) {
                Common &c = *this;
                c.check_fuzz_fn("log");
                c.log_str(String(fmt::sprintln(args...)));
            }

          protected:
            mutable sync::RWMutex mu;                   // guards this group of fields
            String output;                     // Output generated by test or benchmark.
            io::Writer *w;            // For flushToParent.
            bool ran        = false;                 // Test or benchmark (or one of its subtests) was executed.
            bool has_failed = false;                      // Test or benchmark has failed.
            bool has_skipped    = false;                 // Test or benchmark has been skipped.
            bool done       = false;                 // Test is finished and all subtests have completed.
            // helperPCs   map[uintptr]struct{} // functions to be skipped when writing file/line info
            // helperNames map[string]struct{}  // helperPCs converted to function names
            std::vector<std::function<void()>> cleanups;             // optional functions to be called at the end of the test
            // cleanupName string               // Name of the cleanup function.
            // cleanupPc   []uintptr            // The stack trace at the point where Cleanup was called.
            bool finished    = false;                 // Test function has completed.
            bool in_fuzz_fn    = false;                 // Whether the fuzz target, if this is one, is running.
        
            ChattyPrinter *chatty = nil;          // A copy of chattyPrinter, if the chatty flag is set.
            bool bench          = false;           // Whether the current test is a benchmark.
            sync::atomic<bool> has_sub;  // whether there are sub-benchmarks.
            sync::atomic<bool> cleanup_started;    // Registered cleanup callbacks have started to execute
            String runner;                  // Function name of tRunner running the test.
            bool is_parallel = false;           // Whether the test is parallel.
        
            Common *parent = nil;
            int level    = 0;               // Nesting depth of test or benchmark.
            // creator  []uintptr         // If level > 0, the stack trace at the point where the parent called t.Run.
            String name;                 // Name of test or benchmark.
            time::time start; // Time test or benchmark started
            time::duration duration;
            sync::Chan<bool> barrier; // To signal parallel subtests they may start. Nil when T.Parallel is not present (B) or not usable (when fuzzing).
            sync::Chan<bool> signal = sync::Chan<bool>(1);    // To signal a test is done.
            std::vector<T*> sub;      // Queue of subtests to be run in parallel.
        
            // lastRaceErrors  atomic.Int64 // Max value of race.Errors seen during the test or its subtests.
            // raceErrorLogged atomic.Bool
        
            // tempDirMu  sync.Mutex
            // tempDir    string
            // tempDirErr error
            // tempDirSeq int32
        
            // ctx       context.Context
            // cancelCtx context.CancelFunc

            void *run_cleanup(PanicHandling ph);

            // checkRaces checks whether the global count of data race errors has increased
            // since c's count was last reset.
            //
            // If so, it marks c as having failed due to those races (logging an error for
            // the first such race), and updates the race counts for the parents of c so
            // that if they are currently suspended (such as in a call to T.Run) they will
            // not log separate errors for the race(s).
            //
            // Note that multiple tests may be marked as failed due to the same race if they
            // are executing in parallel.
            int64 check_races() {return 0;}

            // resetRaces updates c.parent's count of data race errors (or the global count,
            // if c has no parent), and updates c.lastRaceErrors to match.
            //
            // Any races that occurred prior to this call to resetRaces will
            // not be attributed to c.
            void reset_races() {}

            // log_str generates the output. It's always at the same stack depth.
            void log_str(str s);

            // log_depth generates the output at an arbitrary stack depth.
            void log_depth(str s, int depth);

            // decorate prefixes the string with the file and line of the call site
            // and inserts the final newline if needed and indentation spaces for formatting.
            // This function must be called with c.mu held.
            String decorate(str s, int skip);

            // frame_skip searches, starting after skip frames, for the first caller frame
            // in a function not marked as a helper and returns that frame.
            // The search stops if it finds a tRunner function that
            // was the entry point into the test and the test is not a subtest.
            // This function must be called with c.mu held.
            runtime::Frame frame_skip(int skip);

            void check_fuzz_fn(str);
            void set_ran();

            // flush_to_parent writes c.output to the parent after first writing the header
            // with the given format and arguments.
            void flush_to_parent(str test_name, str s);

            friend Matcher;
            friend BenchState;
            friend std::tuple<bool,bool> run_tests(std::function<bool (str, str, struct error)> match_string, view<InternalTest> tests, time::time deadline);
            friend void t_runner(T &t, std::function<void(T&)> const &fn);
            friend Indenter;
            friend T;
            friend BenchmarkResult testing::benchmark(std::function<void(B &)>);
        } ;

        // TestState holds all fields that are common to all tests. This includes
        // synchronization primitives to run at most *parallel tests.
        struct TestState {
            Matcher *match = nil;
            time::time deadline;

            // isFuzzing is true in the state used when generating random inputs
            // for fuzz targets. isFuzzing is false when running normal tests and
            // when running fuzz tests as unit tests (without -fuzz or when -fuzz
            // does not match).
            bool is_fuzzing = false;

            sync::Mutex mu;

            // Channel used to signal tests that are ready to be run in parallel.
            sync::Chan<bool> start_parallel;

            // running is the number of tests currently running in parallel.
            // This does not include tests that are waiting for subtests to complete.
            int running = 0;

            // numWaiting is the number tests waiting to be run in parallel.
            int num_waiting = 0;

            // maxParallel is a copy of the parallel flag.
            int max_parallel = 0;

            void release();
            void wait_parallel();
        } ;


        // TestDeps is an internal interface of functionality that is
        // passed into this package by a test's generated main package.
        struct TestDeps {
            std::function<String()> import_path;
            std::function<bool(str pat, str s, error)> match_string;
            // SetPanicOnExit0(bool)
            // StartCPUProfile(io.Writer) error
            // StopCPUProfile()
            // StartTestLog(io.Writer)
            // StopTestLog() error
            // WriteProfileTo(string, io.Writer, int) error
            // CoordinateFuzzing(time.Duration, int64, time.Duration, int64, int, []corpusEntry, []reflect.Type, string, string) error
            // RunFuzzWorker(func(corpusEntry) error) error
            // ReadCorpus(string, []reflect.Type) ([]corpusEntry, error)
            // CheckCorpus([]any, []reflect.Type) error
            // ResetCoverage()
            // SnapshotCoverage()
            // InitRuntimeCoverage() (mode string, tearDown func(coverprofile string, gocoverdir string) (string, error), snapcov func() float64)
        } ;

        struct Indenter : io::Writer {
            Common *c = nil;
            Indenter(Common *c) : c(c) {}
            size direct_write(str b, error err) override;
        } ;   

    }

    // T is a type passed to Test functions to manage test state and support formatted test logs.
    //
    // A test ends when its Test function returns or calls any of the methods
    // FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as
    // the Parallel method, must be called only from the goroutine running the
    // Test function.
    //
    // The other reporting methods, such as the variations of Log and Error,
    // may be called simultaneously from multiple goroutines.
    struct T : detail::Common {
        // struct ErrorInfo {
        //     String description;
        //     debug::Backtrace backtrace;
        // };

        // Run runs f as a subtest of t called name. It runs f in a separate goroutine
        // and blocks until f returns or calls t.Parallel to become a parallel test.
        // Run reports whether f succeeded (or at least did not fail before calling t.Parallel).
        //
        // Run may be called simultaneously from multiple goroutines, but all such calls
        // must return before the outer test function for t returns.
        bool run(str name, std::function<void(T &)> f);

    protected:
        bool deny_parallel = false;
        detail::TestState *tstate = nil;

        void report();

        // bool failed_ = false;
        // std::vector<ErrorInfo> errors;
        


        // void fatal(str s) {
        //     errors.push_back({
        //         .description = String(s),
        //         .backtrace = {},
        //     });
            
        //     fatal();
        // }

        // template <typename... Args>
        // void fatalf(str format, Args&&... args) {
        //     String s = fmt::sprintf(format, std::forward<Args>(args)...);
        //     //fmt::printf("FATAL\n");
        //     fmt::printf("FATAL: ");
        //     fmt::printf(s, args...);
        //     fmt::printf("\n");
        //     errors.push_back({
        //         .description = std::move(s),
        //         .backtrace = {},
        //     });
            
        //     fatal();
        // }
        
        // void fail();
        // void fatal();
        // bool failed() {
        //     return failed_;
        // }
        
        // // void operator () (bool);
        friend std::tuple<bool,bool> detail::run_tests(std::function<bool (str, str, struct error)> match_string, view<detail::InternalTest> tests, time::time deadline);
        friend void detail::t_runner(T &t, std::function<void(T&)> const &fn);
    } ; 

    // struct M;
    // M main_start(detail::TestDeps &deps, view<detail::InternalTest> tests,
    //     view<detail::InternalBenchmark> benchmarks,
    //     view<detail::InternalFuzzTarget> fuzz_targets,
    //     view<detail::InternalExample> examples);

    // M is a type passed to a TestMain function to run the actual tests.
    struct M {
        // run runs the tests. It returns an exit code to pass to os.Exit.
        // The exit code is zero when all tests pass, and non-zero for any kind
        // of failure. For machine readable test results, parse the output of
        // 'go test -json'.
        int run();

    protected:
        detail::TestDeps *deps;
        std::vector<detail::InternalTest> tests;
        std::vector<detail::InternalBenchmark> benchmarks;
        std::vector<detail::InternalFuzzTarget> fuzz_targets;
        std::vector<detail::InternalExample> examples;
    
        // timer     *time.Timer
        // afterOnce sync.Once
    
        int num_run = 0;
    
        // value to pass to os.Exit, the outer test func main
        // harness calls os.Exit with this code. See #34129.
        int exit_code = 0;

        // before runs before all testing.
        void before();

        // after runs after all testing.
        void after();

        // start_alarm starts an alarm if requested.
        time::time start_alarm();

        // stop_alarm turns off the alarm.
        void stop_alarm();

        friend int ::main(int argc, char *argv[]);
    } ;
    

    bool short_mode();
    
    // struct TestCase {
    //     str      name;
    //     str      filename;
    //     int      lineno;
        
    //     TestCase(str name, testfunc func, str filename, int lineno);
    // } ;

    // init registers testing flags. These flags are automatically registered by
    // the "go test" command before running test functions, so Init is only needed
    // when calling functions such as Benchmark without using "go test".
    //
    // Init is not safe to call concurrently. It has no effect if it was already called.
    void init();

    // Verbose reports whether the -test.v flag is set.
    bool verbose();

    // M main_start(detail::TestDeps &deps, view<detail::InternalTest> tests,
    //              view<detail::InternalBenchmark> benchmarks,
    //              view<detail::InternalFuzzTarget> fuzz_targets,
    //              view<detail::InternalExample> examples);
}